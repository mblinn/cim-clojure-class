cmdhistory=[";; Switching to cim-clojure-class.1-homework namespace" "(a-list 0)" "(read-string \\"[\:foo \:bar \:baz]\\")" "(\= _ (eval (read-string \\"(+ 1 1)\\")))" "(\= _ (read-string \\"(+ 1 1)\\"))" "(\= [1 2 3] a-vector)" "(\= 2 (eval (read-string \\"(+ 1 1)\\")))" "(clojure.core/ns cim-clojure-class.1-the-beginning)\\n(defn hello-world [] \\n  (println \\"hello, world\\"))\\n(clojure.core/ns cim-clojure-class.1-homework)" "(hello-world)" ";; Switching to cim-clojure-class.1-the-beginning namespace" "(hello-world)" "*ns*" "(hello-world)" "(in-ns 'cim-clojure-class.1-the-beginning)" "(hello, world)" "(hello-world)" "(+ 1 1)" "(* 2 2)" "42" "42.42" "\\"hi\\"" "\\\\a" "(type \\"foo\\")" "(type 42)" "(type 4.4)" "42/43" "(type 42/43)" "hello-world" "(hello-world)" "\:foo" "{\:foo \\"a foo\\", 42 \\"a fourty two\\"}" "{\:foo \\"a foo\\" 42 \\"a fourty two\\"}" "{\:foo \\"a foo\\",,,,,,,,,,,,,,,,,,,,, 42 \\"a fourty two\\"}" "{\:foo}" "{}" "[1 2 3 \\"orange\\"]" "\#{\\"dingo\\" \\"baby\\" \:tree 42}" "\#{42 42}" "(conj \#{\:foo} \:foo)" "(map \:foo \:bar)" "(type {})" "a-map" "something" "a-map" "(a-map \:foo)" "(\:foo a-map)" "(\:quzz a-map)" "(get a-map \:quzz \\"the default\\")" "(\:foo a-set)" "(assoc a-map \:quz \\"quz\\")" "a-map" "(def a-map-2 (assoc a-map \:quz \\"quz\\"))" "a-map-2" "a-map" "(a-vector 0)" "(contains? a-vector 0)" "(a-vector 0)" "(conj a-vector 4)" "a-vector" "(a-set \:foo)" "(\:foo a-set)" "(\:quzz a-set)" "{\:foo nil}" "{nil \\"bar\\"}" "\#{nil \:foo}" "(conj a-set \:quzz)" "(conj a-set \:foo)" "\#{\:foo \:foo}" "(conj a-set \:quz \:quzz \:foo)" "(conj a-vector 99)" "(conj a-map [\:bazz \\"bazz\\"])" " (conj a-map [\:bazz \\"bazz\\"] [\:foooo \\"loooong foooo\\"])" "(str \\"foo \\" \\"bar \\" \\"baz \\")" "(a-function \\"billy\\" \\"jean\\")" "(side-effectful \\"billy jean\\")" "(defn side-effectful [an-argument]\\n  \\"A simple function with a let statement and side effect.\\"\\n  (let [a-string (str \\"an-argument \\" an-argument)]\\n    (println a-string) ;<--- this is a side effect\\n    a-string))" "(side-effectfull \\"billy jean\\")" "(side-effectful \\"billy jean\\")" "(if true \\"this was true\\" \\"this was false\\")" "(def the-if-val (if true \\"this was true\\" \\"this was false\\"))" "(if nil \\"this was true\\" \\"this was false\\")" "(if false \\"this was true\\" \\"this was false\\")" "(if 0 \\"this was true\\" \\"this was false\\")" "(even? 2)" "(even? 3)" "(/ 42 2)" "(half-if-even 42)" "(half-if-even 41)" "(let [foo \\"foo\\"]\\n  (str \\"a foo\! a foo\! \\" foo))" "defprotocol" "foo" "(let [foo \\"foo\\" bar \\"bar\\"])" "(let [foo \\"foo\\" bar \\"bar\\"] foo)" "(get-job-type \\"Mbl\\")" "(get-job-type \\"MBL\\")" "(get-job-type \\"Mishu\\")" "(\= \\"foo\\" \\"foo\\")" "read-vec" "(read-vec 0)" "read-map" "{\:foo \\"bar\\"}" "\:foo" "42" "\\"some jawn\\"" "(def a-var \\"this is the value\\")" "(quote (+ 1 1))" "(+ 1 1)" "(quote (+ 1 1))" "(def a-var \\"this is a value\\")" "(\\"hello\\", \\"world\\")" "'(+ 1 1)" "(+ 1 (+ 1 1))" "(+ 1 1 1 1 1)" "(1 1)" "(first '(+ 1 1))" "(rest '(+ 1 1))" "(print \\"hello\\")" "(println \\"hellp\\")" "read-vec" ";; Switching to cim-clojure-class.2-state namespace" "@an-atom" "(java.lang.Thread/currentThread)" "(pcalls (fn [] (Thread/currentThread)) 5)" "(pcalls 5 (fn [] (Thread/currentThread)))" "(def f (fn [] (java.lang.Thread/currentThread)))" "(apply pcalls [fn fn fn])" "(apply pcalls fn fn fn)" "(apply pcalls [f f f])" "(repeat 5 'foo)" "@an-int-atom" "(add-to-an-int-atom 1)" "@an-int-atom" "(add-to-an-int-atom 99)" "@an-int-agent" "(add-to-an-int-agent 42)" "@an-int-agent" "(conj [] \:foo \:bar)" "(add-to-refs \:foo \\"foo\\")" "(def map-ref (ref {}))" "(def vec-ref (ref []))" "(defn add-to-refs [a b]\\n  (dosync\\n    (alter map-ref assoc a b)\\n    (alter vec ref conj a b)))" "@map-ref" "@vec-ref" "(add-to-refs \:foo \\"foo\\")" "(defn add-to-refs [a b]\\n  (dosync\\n    (alter map-ref assoc a b)\\n    (alter vec-ref ref conj a b)))" "(add-to-refs \:foo \\"foo\\")" "(assoc {} \:foo \\"foo\\")" "@map-ref" "@vec-ref" "(apply conj [] \:foo \\"foo\\")" "(apply assoc [] \:foo \\"foo\\")" "(apply assoc {} \:foo \\"foo\\")" "(defn add-to-refs [value]\\n  (dosync\\n    (alter vec-one value)\\n    (alter vec-two value)))" "(def vec-one (ref []))" "(def vec-two (ref []))" "(add-to-refs [\:foo])" "(defn add-to-refs [value]\\n  (dosync\\n    (alter vec-one value)\\n    (alter vec-two value)))" "(add-to-refs \:foo)" "@vec-one" "(defn add-to-refs [value]\\n  (dosync\\n    (alter vec-one assoc value)\\n    (alter vec-two assoc value)))" "(add-to-refs \:foo)" "(def vec-count (ref 0))" "(def vec-two (ref []))" "(defn add-to-refs [value]\\n  (dosync\\n    (alter vec-count inc value)\\n    (alter vec-two conj value)))" "(add-to-refs 42)" "(defn add-to-refs [value]\\n  (dosync\\n    (alter vec-count + value)\\n    (alter vec-two conj value)))" "(add-to-refs 42)" "@vec-count" "@vec-two" "(def read-vec (read-string \\"[1 2 3]\\"))" "read-vec" "(def read-map (read-string \\"{\:foo \\\\\\"foo\\\\\\" \:bar \\\\\\"bar\\\\\\"}\\"))" "read-map" "(read-string \\"[\:foo \:bar]\\")" "(read-string \\"[\:foo \:bar] [\:baz \:quz]\\")" "(read-string \\"{\:foo \\\\\\"foo\\\\\\"}\\")" "(read-string \\"1\\")" "(type (read-string \\"1\\"))" "(read-string \\"(+ 1 1)\\")" "(type (read-string \\"(+ 1 1)\\"))" "(read-string \\"(\:foo \:bar \:baz)\\")" "(type (read-string \\"(\:foo \:bar \:baz)\\"))" "(eval 1)" "(eval \:foo)" "(eval [\:foo \:bar])" "(eval (read-string \\"(+ 1 1)\\"))" "(read-string \\"(+ 1 1)\\")" "(first (read-string \\"(+ 1 1)\\"))" "(quote (+ 1 1))" "(first (quote (+ 1 1)))" "'(+ 1 1)" "(eval '(+ 1 1))" "(\\"hello\\" \\"world\\")" "(+ 1 1 (+ 2 2) (+ 3 3))" "(str \\"hello \\" \\"world\\")" "(str \\"foo \\" \\"bar \\" \\"bet you thought this was baz\!\\")" "(symbol (str \\"hello-\\" \\"karl\\"))" "(type (symbol (str \\"hello-\\" name)))" "(make-helloer \\"joe\\")" "(type (make-helloer \\"jack\\"))" "(hello-jack)" "`(+ 1 1)" "(clojure.core/+ 1 1)" "`(+ 1 1 ~(+ 1 1))" "(make-heloer-two \\"dingo\\")" "(make-helloer-two \\"dingo\\")" "(hello-dingo)" "(+ 1 (+ 1 1))" "(make-helloer-macro zhen)" "(hello-zhen)" "(macroexpand-1 '(hello-zhen))" "(macroexpand-1 '(make-helloer-macro zhen))" "(macroexpand-1 '(if true \\"true\\" \\"false\\"))" "(macroexpand-1 '(cond (\= false false) \\"false\\" (\= true true) \\"huh\\"))" "(cond (\= true false) \\"this will never be true\\" (\= true true) \\"this is\\")" "(macroexpand-1 '(defn foo [] \\"foo\\"))" "(let [foo \\"foo\\"]\\n  foo)" "(let [foo \\"foo\\"\\n      bar \\"bar\\"]\\n  (str foo bar))" "(let [foo \\"foo\\"] (str \\"this is a foo? \\" foo))" "(let [foo \\"foo\\"])" "(let [foo \\"foo\\"] foo)" "(type nil)" "(let [foo \\"foo\\"] foo)" "(let [foo \\"foo\\"] foo foo)" "(let [foo \\"foo\\" bar \\"bar\\"] bar foo)" "(\= _ a-vector)" "(\= [1 2 3] a-vector)" "(def vec [1 2 3])" "(def test-vec [1 2 3])" "test-vec" "(conj test-vec 4)" "test-vec" "(def test-vec2 (conj test-vec 4))" "test-vec" "test-vec2" "(add-to-refs 100)" "(alter vec-count + value)" "(alter vec-count + 100)" "@vec-count" "@vec-ref" "(add-to-int 100)" ";; Switching to cim-clojure-class.2-state namespace" "(add-to-int-atom 400)" "@int-atom" "(add-to-map-atom \:foo \\"foo string\\")" "(cons [] \:foo)" "(cons \:foo [])" "(filter odd? [1 2 3 4])" "(seq {\:foo \\"foo\\" \:bar \\"bar\\"})" "(into {} [[\:foo \\"foo\\"]])" "(defn odd-value [[_ value]]\\n  (odd? value))" "(odd-value [5 4])" "(odd-value [5 5])" "(filter-odd-values {\:foo 1 \:bar 2})" "(filter-odd-value {\:foo 1 \:bar 2 \:baz 3})" "(filter-odd-values {\:foo 1 \:bar 2 \:baz 3})" "(.toUpperCase 0 1 \\"foo\\")" "(.toUpperCase \\"foo\\" 0 1 \\"foo\\")" "(.toUpper \\"foo\\"  0 1)" "(.methods \\"foo\\")" "(.. class methods \\"foo\\")" "(.toUpperCase \\"foo\\")" "(.toUpperCase (.charAt \\"foo\\" 0))" "(Character/toUpperCase \\\\b)" "(.substring \\"foo\\" 0 1)" "(uppercase-name \\"michael bevilacqua linn\\")" "(string/split \\"foo bar baz\\" \#\\" \\")" "(uppercase-name \\"michael bevilacqua linn\\")" "(str (\\"Michael\\" \\"Bevilacqua\\" \\"Linn\\"))" "(apply str '(\\"Michael\\" \\"Bevilacqua\\" \\"Linn\\"))" "(interpose \\" \\" [\\"foo\\" \\"bar\\" \\"baz\\"])" "(str (interpose \\" \\" [\\"foo\\" \\"bar\\" \\"baz\\"]))" "(uppercase-name \\"michael bevilacqua linn\\")" "(uppercase-names [\\"mike linn\\" \\"jon moore\\"])" "(uppercase-name-values [{\:foo \\"mike linn\\" \:bar \\"jon moore\\"}])" "(uppercase-name-values {\:foo \\"mike linn\\" \:bar \\"jon moore\\"})" "(def names-map {\:foo \\"mike linn\\" \:bar \\"jon moore\\"})" "(map (fn [[_ name]] (uppercase-name name)) names-map)" "(into {} (map (fn [[_ name]] (uppercase-name name)) names-map))" "(uppercase-name-values {\:foo \\"mike linn\\" \:bar \\"jon moore\\"})" "(calculate-discount [100 10])" "(calculate-discount [100 15 150 5])" "(first '(\:foo \:bar \:baz))" "(first [\:foo \:bar \:baz])" "(rest '(\:foo \:bar \:baz))" "(rest [\:foo \:bar \:baz])" "(type (rest [\:foo \:bar \:baz]))" "(rest (rest [\:foo \:bar \:baz]))" "(cons \:foo '(\:bar baz))" "(cons \:foo [\:bar baz])" "(cons \:foo [\:bar \:baz])" "(seq [\:foo \:bar \:baz])" "(type (seq [\:foo \:bar \:baz]))" "(seq {\:foo \\"1\\"})" "(type (seq {\:foo \\"1\\"}))" "(into {} [[\:foo \\"foo\\"]])" "(into [] '(\:foo \:bar))" "(into [1] '(2 3 4))" "(filter odd? [1 2 3 4])" "(filter odd? '(1 2 3 4))" "(seq {\:foo \\"bar\\" \:baz \\"quz\\"})" "(odd-value [1 2])" "(odd-value [1 3])" "(odd-value [\:mark-walberg 2])" "(odd-value [\:mark-walberg \\"foo\\"])" ",st" "(destructuring-example [\:one \:two \:three])" "'(\:foo \:bar \:baz)" "(destructuring-example [\:one \:two \:three])" "(destructuring-example [\:one \:two \:three \:four])" "(destructuring-example [\:one \:two])" "(destructuring-map {\:a-key \\"a-value\\"})" "(defn destructuring-map [{a-value \:a-key second-value \:second-key}]\\n  [a-value second-value])" "(destructuring-map {\:a-key \\"akey\\"})" "(destructuring-map {\:a-key \\"akey\\" \:second-key \\"second-value\\"})" "(destructuring-map-let {\:a-key \\"akey\\" \:second-key \\"second-value\\"})" "(def test-map {\:foo 1 \:bar 2 \:baz 3})" "(filter odd-value test-map)" "(into {} (filter odd-value test-map))" "(filter-odd-values test-map)" "(vowel? \\\\b)" "(seq \\"foobar\\")" "(type (seq \\"foobar\\"))" "(filter vowel? \\"foooooobarrrrbaaaaazzz\\")" "(set (filter vowel? \\"foooooobarrrrbaaaaazzz\\"))" "(inc 1)" "(map inc [1 2 3 4])" "(map inc '(1 2 3 4]))" "(map inc '(1 2 3 4))" "(string/split \\"mike linn\\" \#\\" \\")" "(.length \\"foo\\")" "(. \\"foo\\" length)" "(.length \\"foo\\")" "(Character/toUpperCase \\\\b)" "(str \\"foo \\" \\"baz\\")" "(str/join \\",\\" \\"foo\\" \\"bar\\")" "(string/join [\\"foo\\" \\"bar\\"] \\",\\")" "(string/join \\",\\" [\\"foo\\" \\"bar\\"])" "(str \\"foo\\" \\"bar\\" \\"baz\\" \\"quz\\")" "(str \\"foo\\" 1\\")" "(str \\"foo\\" 1)" "uppercase-part (fn [name-part] (str (Character/toUpperCase (.charAt name-part 0)) (.substring name-part 1 (.length name-part))))" "(def uppercase-part (fn [name-part] (str (Character/toUpperCase (.charAt name-part 0)) (.substring name-part 1 (.length name-part)))))" "(uppercase-part \\"foo\\")" "(map uppercase-part \\"foo bar baz\\")" "(map uppercase-part (string/split \\"foo bar baz\\" \#\\" \\"))" "(interpose \\" \\" '(\\"Foo\\" \\"Bar\\" \\"Baz\\"))" "(apply str (\\"Foo\\" \\" \\" \\"Bar\\" \\" \\" \\"Baz\\"))" "(apply str '(\\"Foo\\" \\" \\" \\"Bar\\" \\" \\" \\"Baz\\"))" "(uppercase-names [\\"mike linn\\" \\"todd walker\\"])" "(uppercase-names {\:foo \\"mike linn\\" \:bar \\"todd walker\\"})" "(uppercase-name-values {\:foo \\"mike linn\\" \:bar \\"todd walker\\"})" "(into {\:foo \\"foo\\"} [\:foo \\"bar\\"])" "(into {\:foo \\"foo\\"} [[\:foo \\"bar\\"]])" "(reduce + [1 2 3 4 5])" "(calculate-discount [100 150 5 7])" "(class \\"foo\\")" "(class (rest [\:foo \:bar]))" "(class [\:foo \:bar])" "(first [\:foo \:bar])" "(as-> dingo [\:foo \:bar \:baz] (rest dingo) (rest dingo))" "(as-> [dingo [\:foo \:bar \:baz]] (rest dingo) (rest dingo))" "(as-> dingo [\:foo \:bar \:baz] (rest dingo) (rest dingo))" "(as-> dingo \:foo dingo)" "(as-> dingo \\"foo\\" dingo)" "(as-> [\:foo \:bar \:baz] dingo (rest dingo) (rest dingo))" "(as-> \\"string\\" aString (.toUpperCase string))" "(as-> \\"string\\" aString (.toUpperCase aString))" "(use 'clojure.inspector)" "(inspect [\:foo \:bar [\:baz \:quz\: [\:fluxx]]])" "(inspect [\:foo])" "(inspect [\:foo [\:bar]])" "(inspect [\:foo])" "(use 'clojure.java.browse)" "(browse-url \\"http\://www.google.com\\")" "(import 'clojure.java.javadoc)" "(use 'clojure.java.javadoc)" "(javadoc String)" "(use 'clojure.repl)" "(use 'clojure.walk)" "(keywordize-keys {\\"foo\\" \\"bar\\" {\\"baz\\" \\"quz\\"}})" "(keywordize-keys {\\"foo\\" {\\"baz\\" \\"quz\\"}})" "(postwalk (fn [f] (println f) '(\:foo (\:bar))))" "(postwalk (fn [f] (println f)) '(\:foo (\:bar)))" "(postwalk-demo '(\:foo (\:bar (\:baz))))" "(select-keys [\:foo \:bar] {\:baz \\"baz\\"})" "(select-keys [\:foo \:bar] {\:baz \\"baz\\" \:foo \\"foo\\"})" "(select-keys {\:baz \\"baz\\" \:foo \\"foo\\"}  [\:foo \:bar])" "(re-seq \#\\".*\\\\s+\\" \\"foo     bar   baz\\")" "(re-seq \#\\"[a-zA-Z0-1]*\\\\s+\\" \\"foo     bar   baz\\")" "  (re-seq \#\\"[a-zA-Z0-1]*\\\\s+\\" \\"foo     bar   baz   \\")" "(for [[foo bar baz] [[\\"foo\\" \\"bar\\" \\"baz\\"] [\\"quzz\\" \\"quzzzz\\" \\"quzzzzzz\\"]]\\n      '(foo bar baz)])" "(for [[foo bar baz] [[\\"foo\\" \\"bar\\" \\"baz\\"] [\\"quzz\\" \\"quzzzz\\" \\"quzzzzzz\\"]]]\\n         '(foo bar baz))" "(for [[foo bar baz] [[\\"foo\\" \\"bar\\" \\"baz\\"] [\\"quzz\\" \\"quzzzz\\" \\"quzzzzzz\\"]]]\\n            [foo bar baz])" "((fn [foo] '(foo)) \\"bar\\")" "(fn [bar] 'bar)" "((fn [bar] 'bar) \\"bar\\")" "((fn [bar] bar) \\"bar\\")" "(cons \\"foo\\" '())" "(list 1 2 3)" "((fn foo [x] '(x)) (+ 2 2))" "'(\:foo)" "(remove odd? [1 2 3 4])"]
eclipse.preferences.version=1
